# DefSubsequence

[[english.command]]
name = "DefSubsequence"
args = ["a", "b"]
body = '
A sequence $#1$ is a subsequence of a sequence $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) element from arbitrary positions.
'

[[russian.command]]
name = "DefSubsequence"
args = ["a", "b"]
body = '
Последовательность $#1$ является подпоследовательностью $#2$, если $#1$ может быть получена из $#2$ удалением нескольких (возможно, ни одного или всех) элементов на произвольных позициях.
'

# DefSubsegment

[[english.command]]
name = "DefSubsegment"
args = ["a", "b"]
body = '
A sequence $#1$ is a subsegment of a sequence $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.
'

[[russian.command]]
name = "DefSubsegment"
args = ["a", "b"]
body = '
Последовательность $#1$ является подотрезком последовательности $#2$, если $#1$ может быть получена из $#2$ удалением нескольких (возможно, ни одного или всех) элементов с начала и нескольких (возможно, ни одного или всех) элементов с конца.
'

# DefSubarray

[[english.command]]
name = "DefSubarray"
args = ["a", "b"]
body = '
An array $#1$ is a subarray of an array $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.
'

[[russian.command]]
name = "DefSubarray"
args = ["a", "b"]
body = '
Массив $#1$ является подмассивом массива $#2$, если $#1$ может быть получен из $#2$ удалением нескольких (возможно, ни одного или всех) элементов с начала и нескольких (возможно, ни одного или всех) элементов с конца.
'

# DefSubstring

[[english.command]]
name = "DefSubstring"
args = ["a", "b"]
body = '
A string $#1$ is a substring of a string $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.
'

[[russian.command]]
name = "DefSubstring"
args = ["a", "b"]
body = '
Строка $#1$ является подстрокой строки $#2$, если $#1$ может быть получена из $#2$ удалением нескольких (возможно, ни одного или всех) символов с начала и нескольких (возможно, ни одного или всех) символов с конца.
'

# DefSubsequenceInd

[[english.command]]
name = "DefSubsequenceInd"
args = ["a", "b"]
body = '
A sequence $#1$ is a subsequence of a sequence $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) element from arbitrary positions.
Two subsequences are considered different if the sets of \textbf{positions} of the deleted elements are different.
'

[[russian.command]]
name = "DefSubsequenceInd"
args = ["a", "b"]
body = '
Последовательность $#1$ является подпоследовательностью $#2$, если $#1$ может быть получена из $#2$ удалением нескольких (возможно, ни одного или всех) элементов на произвольных позициях.
Две подпоследовательности считаются различными, если различаются множества \textbf{позиций} удаленных элементов.
'

# DefSubsegmentInd

[[english.command]]
name = "DefSubsegmentInd"
args = ["a", "b"]
body = '
A sequence $#1$ is a subsegment of a sequence $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.
Two subsequences are considered different if the sets of \textbf{positions} of the deleted elements are different.
'

[[russian.command]]
name = "DefSubsegmentInd"
args = ["a", "b"]
body = '
Последовательность $#1$ является подотрезком последовательности $#2$, если $#1$ может быть получена из $#2$ удалением нескольких (возможно, ни одного или всех) элементов с начала и нескольких (возможно, ни одного или всех) элементов с конца.
Две подпоследовательности считаются различными, если различаются множества \textbf{позиций} удаленных элементов.
'

# DefSubarrayInd

[[english.command]]
name = "DefSubarrayInd"
args = ["a", "b"]
body = '
An array $#1$ is a subarray of an array $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.
Two subarrays are considered different if the sets of \textbf{positions} of the deleted elements are different.
'

[[russian.command]]
name = "DefSubarrayInd"
args = ["a", "b"]
body = '
Массив $#1$ является подмассивом массива $#2$, если $#1$ может быть получен из $#2$ удалением нескольких (возможно, ни одного или всех) элементов с начала и нескольких (возможно, ни одного или всех) элементов с конца.
Два подмассива считаются различными, если различаются множества \textbf{позиций} удаленных элементов.
'

# DefSubstringInd

[[english.command]]
name = "DefSubstringInd"
args = ["a", "b"]
body = '
A string $#1$ is a substring of a string $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.
Two substrings are considered different if the sets of \textbf{positions} of the deleted elements are different.
'

[[russian.command]]
name = "DefSubstringInd"
args = ["a", "b"]
body = '
Строка $#1$ является подстрокой строки $#2$, если $#1$ может быть получена из $#2$ удалением нескольких (возможно, ни одного или всех) символов с начала и нескольких (возможно, ни одного или всех) символов с конца.
Две подстроки считаются различными, если различаются множества \textbf{позиций} удаленных элементов.
'

# DefPermutation

[[english.command]]
name = "DefPermutation"
args = ["n"]
body = '
A permutation of length $#1$ is an array consisting of $#1$ distinct integers from $1$ to $#1$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($#1=3$ but there is $4$ in the array).
'

[[russian.command]]
name = "DefPermutation"
args = ["n"]
body = '
Перестановкой длины $#1$ является массив, состоящий из $#1$ различных целых чисел от $1$ до $#1$ в произвольном порядке. Например, $[2,3,1,5,4]$ "--- перестановка, но $[1,2,2]$ не перестановка ($2$ встречается в массиве дважды) и $[1,3,4]$ тоже не перестановка ($#1=3$, но в массиве встречается $4$).
'

# DefLexMinStr

[[english.command]]
name = "DefLexMinStr"
args = ["a", "b"]
body = '
A string $#1$ is lexicographically smaller than a string $#2$ if and only if one of the following holds:
\begin{itemize}
\item $#1$ is a prefix of $#2$, but $#1 \ne #2$; or
\item in the first position where $#1$ and $#2$ differ, the string $#1$ has a letter that appears earlier in the alphabet than the corresponding letter in $#2$.
\end{itemize}
'

[[russian.command]]
name = "DefLexMinStr"
args = ["a", "b"]
body = '
Строка $#1$ лексикографически меньше строки $#2$, если и только если выполняется одно из следующего:
\begin{itemize}
\item $#1$ “--- префикс $#2$, но $#1 \ne #2$; или
\item в первой позиции, где $#1$ и $#2$ различны, в строке $#1$ находится буква, которая встречается в алфавите раньше, чем соответствующая буква в $#2$.
\end{itemize}
'

# DefLexMinSeq

[[english.command]]
name = "DefLexMinSeq"
args = ["a", "b"]
body = '
A sequence $#1$ is lexicographically smaller than a sequence $#2$ if and only if one of the following holds:
\begin{itemize}
\item $#1$ is a prefix of $#2$, but $#1 \ne #2$; or
\item in the first position where $#1$ and $#2$ differ, the sequence $#1$ has a smaller element than the corresponding element in $#2$.
\end{itemize}
'

[[russian.command]]
name = "DefLexMinSeq"
args = ["a", "b"]
body = '
Последовательность $#1$ лексикографически меньше последовательности $#2$, если и только если выполняется одно из следующего:
\begin{itemize}
\item $#1$ “--- префикс $#2$, но $#1 \ne #2$; или
\item в первой позиции, где $#1$ и $#2$ различны, в последовательности $#1$ элемент меньше, чем соответствующий элемент в $#2$.
\end{itemize}
'

# DefLexMinArr

[[english.command]]
name = "DefLexMinArr"
args = ["a", "b"]
body = '
An array $#1$ is lexicographically smaller than an array $#2$ if and only if one of the following holds:
\begin{itemize}
\item $#1$ is a prefix of $#2$, but $#1 \ne #2$; or
\item in the first position where $#1$ and $#2$ differ, the array $#1$ has a smaller element than the corresponding element in $#2$.
\end{itemize}
'

[[russian.command]]
name = "DefLexMinArr"
args = ["a", "b"]
body = '
Массив $#1$ лексикографически меньше массива $#2$, если и только если выполняется одно из следующего:
\begin{itemize}
\item $#1$ “--- префикс $#2$, но $#1 \ne #2$; или
\item в первой позиции, где $#1$ и $#2$ различны, в массиве $#1$ элемент меньше, чем соответствующий элемент в $#2$.
\end{itemize}
'

# DefLexMinStrEqsz

[[english.command]]
name = "DefLexMinStrEqsz"
args = ["a", "b"]
body = '
A string $#1$ is lexicographically smaller than a string $#2$ of the same length, if and only if the following holds:
\begin{itemize}
\item in the first position where $#1$ and $#2$ differ, the string $#1$ has a letter that appears earlier in the alphabet than the corresponding letter in $#2$.
\end{itemize}
'

[[russian.command]]
name = "DefLexMinStrEqsz"
args = ["a", "b"]
body = '
Строка $#1$ лексикографически меньше строки $#2$ такой же длины, если и только если выполняется следующее:
\begin{itemize}
\item в первой позиции, где $#1$ и $#2$ различны, в строке $#1$ находится буква, которая встречается в алфавите раньше, чем соответствующая буква в $#2$.
\end{itemize}
'

# DefLexMinSeqEqsz

[[english.command]]
name = "DefLexMinSeqEqsz"
args = ["a", "b"]
body = '
A sequence $#1$ is lexicographically smaller than a sequence $#2$ of the same length if and only if the following holds:
\begin{itemize}
\item in the first position where $#1$ and $#2$ differ, the sequence $#1$ has a smaller element than the corresponding element in $#2$.
\end{itemize}
'

[[russian.command]]
name = "DefLexMinSeqEqsz"
args = ["a", "b"]
body = '
Последовательность $#1$ лексикографически меньше последовательности $#2$ такой же длины, если и только если выполняется следующее:
\begin{itemize}
\item в первой позиции, где $#1$ и $#2$ различны, в последовательности $#1$ элемент меньше, чем соответствующий элемент в $#2$.
\end{itemize}
'

# DefLexMinArrEqsz

[[english.command]]
name = "DefLexMinArrEqsz"
args = ["a", "b"]
body = '
An array $#1$ is lexicographically smaller than an array $#2$ of the same size if and only if the following holds:
\begin{itemize}
\item in the first position where $#1$ and $#2$ differ, the array $#1$ has a smaller element than the corresponding element in $#2$.
\end{itemize}
'

[[russian.command]]
name = "DefLexMinArrEqsz"
args = ["a", "b"]
body = '
Массив $#1$ лексикографически меньше массива $#2$ такого же размера, если и только если выполняется следующее:
\begin{itemize}
\item в первой позиции, где $#1$ и $#2$ различны, в массиве $#1$ элемент меньше, чем соответствующий элемент в $#2$.
\end{itemize}
'

# DefBitwiseXOR

[[english.command]]
name = "DefBitwiseXOR"
args = ["\oplus"]
body = '
$\oplus$ denotes the \href{https://en.wikipedia.org/wiki/Bitwise_operation#XOR}{bitwise XOR operation}.
'

[[russian.command]]
name = "DefBitwiseXOR"
args = ["\oplus"]
body = '
$\oplus$ обозначает операцию \href{https://ru.wikipedia.org/wiki/Битовая_операция#Побитовое_исключающее_ИЛИ}{побитового исключающего ИЛИ}.
'

# DefBitwiseOR

[[english.command]]
name = "DefBitwiseOR"
args = ["|"]
body = '
$|$ denotes the \href{https://en.wikipedia.org/wiki/Bitwise_operation#OR}{bitwise OR operation}.
'

[[russian.command]]
name = "DefBitwiseOR"
args = ["|"]
body = '
$|$ обозначает операцию \href{https://ru.wikipedia.org/wiki/Битовая_операция#Побитовое_ИЛИ}{побитового ИЛИ}.
'

# DefBitwiseAND

[[english.command]]
name = "DefBitwiseAND"
args = ["\&"]
body = '
$\&$ denotes the \href{https://en.wikipedia.org/wiki/Bitwise_operation#AND}{bitwise AND operation}.
'

[[russian.command]]
name = "DefBitwiseAND"
args = ["\&"]
body = '
$\&$ обозначает операцию \href{https://ru.wikipedia.org/wiki/Битовая_операция#Побитовое_И}{побитового И}.
'

# DefGCD

[[english.command]]
name = "DefGCD"
args = ["x", "y"]
body = '
$\gcd(#1, #2)$ denotes the \href{https://en.wikipedia.org/wiki/Greatest_common_divisor}{greatest common divisor (GCD)} of integers $#1$ and $#2$.
'

[[russian.command]]
name = "DefGCD"
args = ["x", "y"]
body = '
$\gcd(#1, #2)$ обозначает \href{https://ru.wikipedia.org/wiki/Наибольший_общий_делитель}{наибольший общий делитель (НОД)} чисел $#1$ и $#2$.
'

# DefLCM

[[english.command]]
name = "DefLCM"
args = ["x", "y"]
body = '
$\operatorname{lcm}(#1, #2)$ denotes the \href{https://en.wikipedia.org/wiki/Lowest_common_divisor}{lowest common divisor (LCM)} of integers $#1$ and $#2$.
'

[[russian.command]]
name = "DefLCM"
args = ["x", "y"]
body = '
$\operatorname{lcm}(#1, #2)$ обозначает \href{https://ru.wikipedia.org/wiki/Наименьшее_общее_кратное}{наименьшее общее кратное (НОК)} чисел $#1$ и $#2$.
'

# DefMEX

[[english.command]]
name = "DefMEX"
args = ["c", "k", "x"]
body = '
$\operatorname{mex}(#1)$ denotes the minimmum excluded (MEX)\footnote{\DefMEXfull[#1][#2][#3]} of the collection $#1$.
'

[[russian.command]]
name = "DefMEX"
args = ["c", "k", "x"]
body = '
$\operatorname{mex}(#1)$ обозначает наименьшее исключенное (MEX)\footnote{\DefMEXfull[#1][#2][#3]} набора чисел $#1$.
'

# DefMEXfull

[[english.command]]
name = "DefMEXfull"
args = ["c", "k", "x"]
body = '
The minimum excluded (MEX) of a collection of integers $#1_1, #1_2, \ldots, #1_#2$ is defined as
the smallest non-negative integer $#3$ which does not occur in the collection $#1$.
'

[[russian.command]]
name = "DefMEXfull"
args = ["c", "k", "x"]
body = '
Наименьшее исключенное (MEX) набора чисел $#1_1, #1_2, \ldots, #1_#2$ определяется как
наименьшее неотрицательное целое число $#3$, которое не встречается в наборе чисел $#1$.
'

# DefMOD

[[english.command]]
name = "DefMOD"
args = ["x", "y"]
body = '
$#1 \bmod #2$ denotes the remainder from dividing $#1$ by $#2$.
'

[[russian.command]]
name = "DefMOD"
args = ["x", "y"]
body = '
$#1 \bmod #2$ обозначает остаток от деления $#1$ на $#2$.
'

# DefTestcases

[[english.command]]
name = "DefTestcases"
args = ["t", "10^4"]
body = '
Each test contains multiple test cases.
The first line contains the number of test cases $#1$ ($1 \le #1 \le #2$).
The description of the test cases follows.
'

[[russian.command]]
name = "DefTestcases"
args = ["t", "10^4"]
body = '
Каждый тест состоит из нескольких наборов входных данных.
В первой строке находится одно целое число $#1$ ($1 \le #1 \le #2$) “--- количество наборов входных данных.
Далее следует описание наборов входных данных.
'

# DefLimitSum

[[english.command]]
name = "DefLimitSum"
args = ["n", "10^5"]
body = '
It is guaranteed that the sum of $#1$ over all test cases does not exceed $#2$.
'

[[russian.command]]
name = "DefLimitSum"
args = ["n", "10^5"]
body = '
Гарантируется, что сумма значений $#1$ по всем наборам входных данных не превосходит $#2$.
'

# DefSubtask

[[english.command]]
name = "DefSubtask"
args = ["easy", "???"]
body = '
\textbf{This is the #1 version of the problem. The difference between the versions is that in this version, #2. You can hack only if you solved all versions of this problem.}
'

[[russian.command]]
name = "DefSubtask"
args = ["простая", "???"]
body = '
\textbf{Это #1 версия задачи. Отличие между версиями заключается в том, что в этой версии #2. Вы можете делать взломы только в том случае, если решили все версии этой задачи.}
'

# DefInteractive

[[english.command]]
name = "DefInteractive"
args = []
body = '
\textit{This is an interactive problem.}
'

[[russian.command]]
name = "DefInteractive"
args = []
body = '
\textit{Это интерактивная задача.}
'

# DefFlush

[[english.command]]
name = "DefFlush"
args = ["$-1$"]
body = '
After printing each query do not forget to output the end of line and flush\footnote{To
flush, use:
\begin{itemize}
\item \t{fflush(stdout)} or
\t{cout.flush()} in C++;
\item \t{sys.stdout.flush()} in
Python;
\item see the documentation for
other languages.
\end{itemize}} the output. Otherwise, you will get
\t{Idleness limit exceeded} verdict.

If, at any interaction step, you read #1 instead of valid data, your solution must exit immediately.
This means that your solution will reveive \t{Wrong answer} because of an invalid query or any other mistake.
Failing to exit can result in an arbitrary verdict because your solution will continue to read from a closed stream.
'

[[russian.command]]
name = "DefFlush"
args = ["$-1$"]
body = '
После вывода каждого запроса не забудьте вывести перевод строки и сбросить буфер вывода\footnote{Чтобы сбросить буфер вывода, используйте:
\begin{itemize}
\item \t{fflush(stdout)} или
\t{cout.flush()} в C++;
\item \t{sys.stdout.flush()} в
Python;
\item смотрите документацию для других языков.
\end{itemize}}. В противном случае вы получите вердикт
\t{Решение <<зависло>>}. 

На любом шаге взаимодействия, если вы считали #1 вместо корректных данных, ваше решение должно немедленно завершиться.
Это означает, что ваше решение получит вердикт \t{Неправильный ответ} из-за некорректного запроса или любой другой ошибки.
Если программа не завершится, вы можете получить любой вердикт, так как ваша программа продолжит чтение из закрытого потока.
'

# DefPrecision

[[english.command]]
name = "DefPrecision"
args = ["10^{-9}", "a", "b"]
body = '
Your answer is considered correct if its absolute or relative error does not exceed $#1$.

Formally, let your answer be $#2$, and the jury's answer be $#3$.
Your answer is accepted if and only if $\frac{|#2 - #3|}{\max{(1, |#3|)}} \le #1$.
'

[[russian.command]]
name = "DefPrecision"
args = ["$10^{-9}$", "a", "b"]
body = '
Ваш ответ будет считаться правильным, если его абсолютная или относительная ошибка не превосходит $#1$.

Формально, пусть ваш ответ равен $#2$, а ответ жюри равен $#3$.
Ваш ответ будет зачтен, если и только если $\frac{|#2 - #3|}{\max{(1, |#3|)}} \le #1$.
'

# DefModuloFraqAnswer

[[english.command]]
name = "DefModuloFraqAnswer"
args = ["998\,244\,353", "M", "p", "q", "x"]
body = '
Formally, let $#2 = #1$.
It can be shown that the exact answer can be expressed as an irreducible fraction $\frac{#3}{#4}$,
where $#3$ and $#4$ are integers and $#4 \not \equiv 0 \pmod{#2}$.
Output the integer equal to $#3 \cdot #4^{-1} \bmod #2$.
In other words, output such an integer $#5$ that $0 \le x < #2$ and $#5 \cdot #4 \equiv #3 \pmod{#2}$.
'

[[russian.command]]
name = "DefModuloFraqAnswer"
args = ["998\,244\,353", "M", "p", "q", "x"]
body = '
Формально, пусть $#2 = #1$.
Можно показать, что точный ответ может быть представлен в виде несократимой дроби $\frac{#3}{#4}$,
где $#3$ и $#4$ "--- целые числа, и $#4 \not \equiv 0 \pmod{#2}$.
Выведите целое число, равное $#3 \cdot #4^{-1} \bmod #2$.
Другими словами, выведите такое целое число $#5$, что $0 \le x < #2$ и $#5 \cdot #4 \equiv #3 \pmod{#2}$.
'



# Common

[[common.command]]
name = "DefTriangleNumber"
args = [""]
body = '
\frac{#1\cdot(#1-1)}{2}
'
